
val glob = { glob =>
  type Pair: Bot .. Top { z =>
    type T: Bot .. Top
    val fst: z.T
    val snd: z.T
    def setFst: z.T -> glob.Pair{T = z.T}
    def setSnd: z.T -> glob.Pair{T = z.T}
  }
  
  def swap(p: glob.Pair): glob.Pair{T = p.T} = {
    val oldFst: p.T = p.fst  // <--- consider this line here
    val p2: glob.Pair{T = p.T} = p.setFst(p.snd)
    p2.setSnd(oldFst)
  }
}

Let's interpret the "T { z => D1, ... Dn }" notation used above as "âˆƒz:T & {D1} & ... & {Dn}.T & {D1} & ... & {Dn}" (that's how we would represent refinement types, as far is I understood).

Now let G = { glob: (type glob object), p: glob.Pair },
and let's show "G |- p.fst : p.T".


