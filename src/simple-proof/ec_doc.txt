
Representing evaluation contexts


TODO insert Coq here

Representing terms

In general, there may be multiple decompositions of a term into an evaluation context
and a subterm. For example, the term

let x = v1 in let y = v2 in x y

decomposes in three ways:

[let x = v1 in let y = v2 in x y]
let x = v1 in [let y = v2 in x y]
let x = v1 in let y = v2 in [x y]

However, the reduction rules cannot apply to any of the decompositions except the
last one, because none of the reduction rules match the syntactic pattern

e[let x = v in t]

Therefore, the only decomposition to which a reduction rule can possibly apply
is the maximal one, where all prefixes of the form

let x = v in

have been shifted into the evaluation context.

In the proof, we represent terms in this maximally decomposed way, in the form
of a pair (e,t) of an evaluation context and a term.

A term of the form

let x = t in u

can be decomposed into evaluation contexts in two ways:

[let x = t in u]  (1)
let x = [t] in u  (2)

Similarly, a term of the form

let x = v in u

can be decomposed into evaluation contexts in three ways:

[let x = v in u]  (3)
let x = [v] in u  (4)
let x = v in [u]  (5)

Of these different decompositions of the same two terms, the reduction
rules can apply only to decompositions (2) and (5).

We add congruence reduction rules to reduce the decomposition (1) to
decomposition (2) and decompositions (3) and (4) to decomposition (5).

e[.] | let x = t in u -> e[let x = [.] in u] | t
(Congruence-Let)

e[let x = [.] in u] | v -> e[let x = v in [.]] | u
(Congruence-Val)

Rule (Congruence-Let) reduces (1) to (2). It also reduces (3) to (4).
Rule (Congruence-Val) then further reduces (4) to (5).


Typing for decomposed terms

We define a typing relation for pairs (e,t) of an evaluation context and a term.
The pair (e,t) has type T in typing context Gamma if and only if the term
e[t] has type T in typing context Gamma according to the general typing
relation for terms.
